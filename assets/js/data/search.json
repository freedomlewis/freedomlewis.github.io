[ { "title": "What is AI", "url": "/posts/what-is-AI/", "categories": "Tech", "tags": "AI", "date": "2025-01-25 04:07:00 +0000", "snippet": "Artificial intelligence (AI), in its broadest sense, is intelligence exhibited by machines, particularly computer systems. It is a field of research in computer science that develops and studies methods and software that enable machines to perceive their environment and use learning and intelligence to take actions that maximize their chances of achieving defined goals. Such machines may be called AIs.AI vs ML vs DLHow deep learning is a subset of machine learning and how machine learning is a subset of artificial intelligence (AI)AI CategoryArtificial general intelligenceArtificial general intelligence (AGI) is a type of artificial intelligence (AI) that matches or surpasses human cognitive capabilities across a wide range of cognitive tasks. This contrasts with narrow AI, which is limited to specific tasks. Artificial superintelligence (ASI), on the other hand, refers to AGI that greatly exceeds human cognitive capabilities. AGI is considered one of the definitions of strong AI.Weak artificial intelligenceWeak artificial intelligence (weak AI) is artificial intelligence that implements a limited part of the mind, or, as Artificial Narrow Intelligence, is focused on one narrow task.Narrow AI can be classified as being “limited to a single, narrowly defined task. Most modern AI systems would be classified in this category.” Artificial general intelligence is conversely the opposite.Machine LearningMachine learning (ML) is a field of study in artificial intelligence concerned with the development and study of statistical algorithms that can learn from data and generalize to unseen data, and thus perform tasks without explicit instructions.Deep LearningDeep learning is a subset of machine learning that focuses on utilizing neural networks to perform tasks such as classification, regression, and representation learning. The field takes inspiration from biological neuroscience and is centered around stacking artificial neurons into layers and “training” them to process data. The adjective “deep” refers to the use of multiple layers (ranging from three to several hundred or thousands) in the network. Methods used can be either supervised, semi-supervised or unsupervised.Early forms of neural networks were inspired by information processing and distributed communication nodes in biological systems, particularly the human brain. However, current neural networks do not intend to model the brain function of organisms, and are generally seen as low-quality models for that purpose.Supervised learning vs Unsupervised learningIn supervised learning, the training data is labeled with the expected answers, while in unsupervised learning, the model identifies patterns or structures in unlabeled data.Supervised learningIn machine learning, supervised learning (SL) is a paradigm where a model is trained using input objects (e.g. a vector of predictor variables) and desired output values (also known as a supervisory signal), which are often human-made labels. The training process builds a function that maps new data to expected output values.[1] An optimal scenario will allow for the algorithm to accurately determine output values for unseen instances. This requires the learning algorithm to generalize from the training data to unseen situations in a “reasonable” way (see inductive bias). This statistical quality of an algorithm is measured via a generalization error.Unsupervised learningUnsupervised learning is a framework in machine learning where, in contrast to supervised learning, algorithms learn patterns exclusively from unlabeled data.Other frameworks in the spectrum of supervisions include weak- or semi-supervision, where a small portion of the data is tagged, and self-supervision. Some researchers consider self-supervised learning a form of unsupervised learning.Conceptually, unsupervised learning divides into the aspects of data, training, algorithm, and downstream applications. Typically, the dataset is harvested cheaply “in the wild”, such as massive text corpus obtained by web crawling, with only minor filtering (such as Common Crawl). This compares favorably to supervised learning, where the dataset (such as the ImageNet1000) is typically constructed manually, which is much more expensive.There were algorithms designed specifically for unsupervised learning, such as clustering algorithms like k-means, dimensionality reduction techniques like principal component analysis (PCA), Boltzmann machine learning, and autoencoders. After the rise of deep learning, most large-scale unsupervised learning have been done by training general-purpose neural network architectures by gradient descent, adapted to performing unsupervised learning by designing an appropriate training procedure.Sometimes a trained model can be used as-is, but more often they are modified for downstream applications. For example, the generative pretraining method trains a model to generate a textual dataset, before finetuning it for other applications, such as text classification. As another example, autoencoders are trained to good features, which can then be used as a module for other models, such as in a latent diffusion model.Weak supervisionWeak supervision (also known as semi-supervised learning) is a paradigm in machine learning, the relevance and notability of which increased with the advent of large language models due to large amount of data required to train them. It is characterized by using a combination of a small amount of human-labeled data (exclusively used in more expensive and time-consuming supervised learning paradigm), followed by a large amount of unlabeled data (used exclusively in unsupervised learning paradigm). In other words, the desired output values are provided only for a subset of the training data. The remaining data is unlabeled or imprecisely labeled. Intuitively, it can be seen as an exam and labeled data as sample problems that the teacher solves for the class as an aid in solving another set of problems. In the transductive setting, these unsolved problems act as exam questions. In the inductive setting, they become practice problems of the sort that will make up the exam.Reinforcement LearningReinforcement learning (RL) is an interdisciplinary area of machine learning and optimal control concerned with how an intelligent agent should take actions in a dynamic environment in order to maximize a reward signal. Reinforcement learning is one of the three basic machine learning paradigms, alongside supervised learning and unsupervised learning.Reinforcement learning differs from supervised learning in not needing labelled input-output pairs to be presented, and in not needing sub-optimal actions to be explicitly corrected. Instead, the focus is on finding a balance between exploration (of uncharted territory) and exploitation (of current knowledge) with the goal of maximizing the cumulative reward (the feedback of which might be incomplete or delayed).The search for this balance is known as the exploration-exploitation dilemma.The environment is typically stated in the form of a Markov decision process (MDP), as many reinforcement learning algorithms use dynamic programming techniques.The main difference between classical dynamic programming methods and reinforcement learning algorithms is that the latter do not assume knowledge of an exact mathematical model of the Markov decision process, and they target large MDPs where exact methods become infeasible.Data ScienceData science is an interdisciplinary academic field that uses statistics, scientific computing, scientific methods, processing, scientific visualization, algorithms and systems to extract or extrapolate knowledge and insights from potentially noisy, structured, or unstructured data.Data science also integrates domain knowledge from the underlying application domain (e.g., natural sciences, information technology, and medicine).Data science is multifaceted and can be described as a science, a research paradigm, a research method, a discipline, a workflow, and a profession.Data science is “a concept to unify statistics, data analysis, informatics, and their related methods” to “understand and analyze actual phenomena” with data.It uses techniques and theories drawn from many fields within the context of mathematics, statistics, computer science, information science, and domain knowledge.However, data science is different from computer science and information science. Turing Award winner Jim Gray imagined data science as a “fourth paradigm” of science (empirical, theoretical, computational, and now data-driven) and asserted that “everything about science is changing because of the impact of information technology” and the data deluge.A data scientist is a professional who creates programming code and combines it with statistical knowledge to create insights from data.ReferenceArtificial intelligence：https://en.wikipedia.org/wiki/Artificial_intelligence#LearningArtificial general intelligence：https://en.wikipedia.org/wiki/Artificial_general_intelligenceWeak artificial intelligence：https://en.wikipedia.org/wiki/Weak_artificial_intelligenceMachine learning：https://en.wikipedia.org/wiki/Machine_learning " }, { "title": "Review of 2024 &amp; Hopes for 2025", "url": "/posts/summary-of-2024/", "categories": "Summary", "tags": "My", "date": "2024-12-31 07:12:00 +0000", "snippet": "Improvements: English communication skills Know the principle that customer first and help the customer success Know the value of do right thing Really know what means of fast is slow, even though I heard this long before Know the value of waiting and be patientKey Lessons Learned: Be patient, no rush Where you put the time, what you will gain Less thought, do More Opportunities are always there, don’t rush to jump in Be grateful to othersHopes for 2025: Make my wife happier than 2024 Travel with my families once 12 blogs related to AI Try my best to help my customer success Do meditation everyday Life is short, do not live in someone else’s life, be yourself and build something You deserve a better life" }, { "title": "Move camera in Android simulator", "url": "/posts/tech-android-move-camera/", "categories": "Tech", "tags": "Android", "date": "2024-12-31 04:06:00 +0000", "snippet": "What’s the issueI want to test a scan QRCode feature on the Android simulator, but I found it’s unable to move the camera and also the image I set for the simulator not display in the camera preview screen.How to fixIf we want to move the camera in Simulator, follow the below settings: Run the simulator as a standalone App Set a picture to show in the simulator camera Move the camera press the Option button and WSAD to adjust direction" }, { "title": "Living a Better Life with Benjamin Franklin&#39;s 13 Virtues", "url": "/posts/Franklin-13-virtues/", "categories": "North Star", "tags": "Habit", "date": "2024-06-16 08:57:00 +0000", "snippet": "Benjamin Franklin, one of the Founding Fathers of the United States, was not only a prominent statesman but also a philosopher who believed in the constant pursuit of self-improvement. In his autobiography, he outlined thirteen virtues that he believed were essential for personal growth and living a better life. These virtues are timeless principles that can still guide us today. Let’s explore each virtue and how we can incorporate them into our daily lives.1. Temperance (节制)Eat not to dullness; drink not to elevation. (食不过饱，饮不过量。)Temperance is about moderation in all things, especially in eating and drinking. Overindulgence can lead to health issues and clouded judgment. By practicing temperance, we can maintain clarity of mind and body.2. Silence (沉默)Speak not but what may benefit others or yourself; avoid trifling conversation. (言必于人于己有益；禁止无益的闲谈。)Silence encourages us to speak only when it adds value. Avoiding idle chatter helps us to focus on meaningful conversations and thoughtful reflection.3. Order (秩序)Let all your things have their places; let each part of your business have its time. (一切东西都有自己的位置；日常事务何时起、何时完，当有它们的安排。)Orderliness ensures that everything has its place and time. By organizing our environment and tasks, we can increase efficiency and reduce stress.4. Resolution (决心)Resolve to perform what you ought; perform without fail what you resolve. (当做必做；决心要做的事坚持不懈。)Resolution is about determination and commitment. Once we decide to do something, we should follow through with unwavering dedication.5. Frugality (俭朴)Make no expense but to do good to others or yourself; i.e., waste nothing. (用钱必于人于己有益，戒除浪费。)Frugality teaches us to spend wisely and avoid waste. By being prudent with our resources, we can contribute to our well-being and that of others.6. Industry (勤劳)Lose no time; be always employed in something useful; cut off all unnecessary actions. (勿浪费时间；每时每刻做有用的事，戒除不必要的行动。)Industry encourages productivity and purposeful action. By staying engaged in useful activities, we can make the most of our time and talents.7. Sincerity (诚恳)Use no hurtful deceit; think innocently and justly, and, if you speak, speak accordingly. (不欺骗人；勿思邪恶，唯念正义，说话也应如此。)Sincerity is about honesty and integrity. By being truthful and just in our thoughts and words, we build trust and respect in our relationships.8. Justice (正直)Wrong none by doing injuries or omitting the benefits that are your duty. (不做有害他人的事，也不要忘记履行对人有益的应尽义务。)Justice involves fairness and doing what is right. We should strive to treat others equitably and fulfill our obligations to society.9. Moderation (中庸)Avoid extremes; forbear resenting injuries so much as you think they deserve. (避免极端；若受到应得的处罚，要容忍，勿发怒。)Moderation is the key to balance. By avoiding extreme behaviors and emotions, we can maintain harmony and perspective in our lives.10. Cleanliness (清洁)Tolerate no uncleanliness in body, clothes, or habitation. (身体、衣服、住所力求清洁。)Cleanliness promotes health and well-being. Keeping ourselves and our surroundings clean helps prevent illness and creates a pleasant living environment.11. Tranquillity (宁静)Be not disturbed at trifles or at accidents common or unavoidable. (勿因琐事或无法避免的普通小事而惊慌失措。)Tranquillity is about maintaining peace of mind. By not getting upset over small or unavoidable issues, we can preserve our inner calm and focus on what truly matters.12. Chastity (贞洁)Rarely use venery but for health or offspring; never to dullness, weakness, or the injury of your own or another’s peace or reputation. (除为了健康或者生育后代，不行房事；万不可房事过度伤害身体，不要损害自己或者他人的安宁或者名誉。)Chastity involves exercising self-control in matters of sexual conduct. It promotes physical health and respects the emotional well-being of ourselves and others.13. Humility (谦逊)Imitate Jesus and Socrates. (仿效耶稣和苏格拉底。)Humility is the foundation of personal growth. By recognizing our limitations and valuing the wisdom of others, we remain open to learning and self-improvement.By incorporating these virtues into our daily lives, we can strive towards personal excellence and a more fulfilling life. Franklin’s wisdom offers a practical guide for self-improvement that remains relevant even in today’s fast-paced world. Start with one virtue, and gradually build up to embodying all thirteen. Your journey towards a better life begins with a single step." }, { "title": "The Balancing Act - Backward Compatibility vs. Forward Compatibility in Software Development", "url": "/posts/backward-forward-compatibility/", "categories": "Tech", "tags": "Android", "date": "2024-05-10 10:29:00 +0000", "snippet": "The Balancing Act: Backward Compatibility vs. Forward Compatibility in Software DevelopmentIn the ever-evolving world of software development, change is inevitable. New features are introduced, bugs are squashed, and underlying technologies advance. But how do we ensure that these changes don’t break the things that already work? This is where backward compatibility and forward compatibility come into play.Backward Compatibility: Keeping the Past AliveBackward compatibility refers to the ability of a new software version to work with existing code, data, and hardware designed for an older version. It’s like building a bridge between the past and present, allowing users and developers to seamlessly transition to the new without starting from scratch.Benefits of Backward Compatibility: Protects Investments: Imagine a company relying on a complex codebase built with an older framework. Backward compatibility ensures their existing code continues to function, saving them the hefty cost of rewriting everything. Smoother Upgrades: Users want to enjoy the benefits of new features without a major disruption in how they use the software. Backward compatibility makes upgrades less daunting, encouraging adoption. Maintains Trust: When users know their existing data and workflows won’t be disrupted by updates, it fosters trust and confidence in the software.Example:Imagine a popular game with millions of players. A new version might introduce exciting new levels. However, backward compatibility ensures that players can still access and enjoy their saved games and achievements from previous versions.Forward Compatibility: Embracing the Unknown FutureForward compatibility, on the other hand, is about designing software that can handle data or code created with a future version. It’s like building a flexible system that can adapt to changes we can’t quite predict yet.Benefits of Forward Compatibility: Future-Proofs Development: By considering potential future needs, software becomes more adaptable. New features or integrations can be introduced more easily without major overhauls. Simplifies Upgrades: Forward compatibility enables smoother integration of future versions of libraries or frameworks, promoting a more efficient development process. Extensibility: A forward-compatible system can be readily extended with new functionalities without breaking existing features, keeping it relevant and competitive.Example:Imagine a data storage format that uses a flexible schema. This schema can accommodate additional data fields in future versions without compromising its ability to read older data.The Balancing ActWhile both backward and forward compatibility are desirable, achieving a perfect balance can be challenging. Over-emphasizing backward compatibility can restrict innovation, while neglecting it can create upgrade headaches. Here’s how to strike the right balance: Clearly Define Compatibility Scope: Specify the range of past and future versions your software supports. This helps manage user expectations and development efforts. Adopt Sensible Design Practices: Modular architecture, clear documentation, and well-defined APIs can make your software more adaptable to future changes. Communicate Openly: Inform users and developers about upcoming changes and potential impact on compatibility. Transparency builds trust and smoother transitions.ConclusionBackward and forward compatibility are essential considerations for any software project. By understanding their importance and striking a balance, developers can create software that endures, adapts, and remains valuable to users over time. So, the next time you’re coding, remember – it’s all about building a bridge between yesterday, today, and the exciting possibilities of tomorrow!" }, { "title": "Demystifying HashMap - A Look Under the Hood", "url": "/posts/HashMap/", "categories": "Tech", "tags": "Data Structure", "date": "2024-04-30 04:29:00 +0000", "snippet": "HashMap is a fundamental data structure in the Java world, widely used for its efficient key-value pair storage and retrieval. But have you ever wondered how it all works behind the scenes? In this blog, we’ll delve into the implementation details of HashMap, exploring its core components and operations.Understanding the Basics: Keys, Values, and HashingAt its heart, HashMap stores key-value pairs. Keys act as unique identifiers for accessing the corresponding values. However, efficiently finding a specific value based on its key is crucial. This is where hashing comes in. The hashCode() method plays a vital role. It transforms each key into a unique integer (hash code). This hash code is then used to map the key-value pair to a specific bucket within an internal array.The Inner Workings: Buckets and Collision ResolutionHashMap utilizes an internal array of buckets. Ideally, each key would have its own dedicated bucket. However, in reality, collisions occur when multiple keys hash to the same value. To resolve collisions, HashMap employs various techniques. One common approach is chaining. In chaining, collided key-value pairs are linked together in a separate data structure (like a linked list) attached to the bucket.Putting It All Together: Key OperationsNow, let’s explore some key HashMap operations: put(key, value): This method adds a new key-value pair to the HashMap. It first calculates the hash code for the key. Then, it finds the corresponding bucket and inserts the key-value pair. If a collision occurs, the entry is chained to the existing entries in that bucket. get(key): This method retrieves the value associated with a specific key. It calculates the hash code for the key and locates the corresponding bucket. Then, it iterates through the chain of entries (if any) searching for the matching key. If found, the value is returned. remove(key): This method removes a key-value pair from the HashMap. Similar to get, it finds the bucket using the key’s hash code. Then, it iterates through the chain searching for the key. Once found, the entry is removed from the chain.Performance Considerations: Load Factor and RehashingHashMap’s performance heavily relies on a concept called load factor. It represents the ratio of key-value pairs to the number of buckets. As the load factor increases (more entries added), collisions become more frequent, impacting performance. To maintain efficiency, HashMap utilizes a technique called rehashing. When the load factor reaches a predefined threshold, the HashMap automatically resizes its internal bucket array and redistributes the entries. This minimizes collisions and ensures optimal performance.Beyond the Basics: Exploring HashMap’s AdvancementsJava HashMap offers additional features to cater to specific use cases: containsKey(key): This method checks if a specific key exists in the HashMap without retrieving the value. entrySet(): This method returns a set of all key-value pairs in the HashMap. Iterators: HashMap provides iterators to traverse over keys or key-value pairs. Custom Key Classes: You can create your own key classes as long as they implement the hashCode() and equals() methods correctly.Conclusion: HashMap - A Powerful and Versatile ToolBy understanding the internal workings of HashMap, you gain valuable insight into its strengths and potential trade-offs. HashMap offers a powerful and versatile data structure for storing and retrieving key-value pairs efficiently. By leveraging its functionalities effectively, you can optimize your Java applications and streamline data management tasks." }, { "title": "Unveiling the Android LRUCache - A Peek Under the Hood", "url": "/posts/LRUCache/", "categories": "Tech", "tags": "Android, Data Structure", "date": "2024-04-30 04:02:00 +0000", "snippet": "Ever wondered how Android keeps your frequently used data readily available while maintaining smooth performance? A significant player in this game is the LRUCache (Least Recently Used Cache). This powerful class efficiently manages data storage, prioritizing what you use most often. But LRUCache doesn’t operate in isolation; it relies on a trusted companion called LinkedHashMap. In this blog, we’ll dissect the inner workings of Android’s LRUCache implementation, exploring how it leverages LinkedHashMap to achieve optimal performance.Understanding LRU Caching: The Balancing ActImagine you’re constantly switching between apps on your phone. LRU Cache steps in to ensure a seamless experience. It prioritizes data you use frequently, storing it within easy reach. When new data arrives and the cache reaches its predefined size limit, LRUCache gracefully evicts the least recently used data, making space for the new information. This ensures you have fast access to the most relevant data, optimizing app performance and user experience.The Brains of the Operation: LRUCache’s Internal WorkingsAt the core of LRUCache lies LinkedHashMap. It provides a robust foundation with a doubly linked list structure. Think of each data entry (key-value pair) as a train car linked to the one before and after it. This structure facilitates efficient operations like adding, removing, and accessing entries based on their usage order.Key Methods in Action: put(key, value): This method is the workhorse for adding new entries. It checks if the cache is full. If so, it triggers the eviction process (more on that later). get(key): This method retrieves a data entry based on the provided key. If found, it might also update the entry’s position within the linked list, signifying recent use (like moving a train car to the front of the locomotive). remove(key): This method removes a specific entry from the cache, essentially unlinking it from the train. sizeOf(key, value) (Optional): This method allows for customization. You can define how the cache calculates the size of each entry. By default, it considers the object’s memory footprint.Eviction Strategy: Making Way for the NewWhen the cache reaches its capacity and a new entry needs a spot, eviction becomes necessary. LRUCache employs a clear strategy: it removes the eldest entry (the caboose of our train analogy). This ensures the cache prioritizes the most recently used data, optimizing resource utilization.The Unsung Hero: How LinkedHashMap Supports LRUCacheWhile LRUCache takes the spotlight, LinkedHashMap silently contributes to the success of the operation. Here’s how: Ordered Structure: LinkedHashMap maintains the doubly linked list, ensuring entries are ordered based on their access time. Fast Access and Updates: This structure allows for quick retrieval and update of entries based on their position in the list. Efficient Removal: When eviction is necessary, LinkedHashMap efficiently removes the eldest entry from the linked list.A Well-Oiled Machine: Collaboration for EfficiencyLRUCache leverages the strengths of LinkedHashMap to achieve efficient LRU caching. The combination provides a robust and scalable solution for managing data in Android applications.Beyond the Basics: Customizing the Cache for Specific NeedsThe beauty of LRUCache lies in its flexibility. Here’s how you can tailor it for your applications: Override Methods: Techniques like overriding the entryRemoved method allow you to define custom behavior when an entry is evicted (e.g., releasing resources associated with the evicted data). Size Calculation: The sizeOf method lets you customize how the cache calculates the size of each entry.Unveiling the Secrets: ConclusionBy understanding the intricate collaboration between LRUCache and LinkedHashMap, you gain valuable insight into how Android manages data efficiently. This knowledge empowers you to optimize your own applications and leverage caching techniques effectively. So next time you experience the seamless performance of Android, remember the silent heroes – LRUCache and LinkedHashMap – working tirelessly in the background!" }, { "title": "Building Your Android App (MVC vs. MVP vs. MVVM) - A Smackdown", "url": "/posts/MVC-MVP-MVVM/", "categories": "Tech", "tags": "Architecture, Android", "date": "2024-04-22 04:29:00 +0000", "snippet": "The realm of Android app development empowers you to craft exceptional applications. But with this power comes a crucial decision: selecting the right architectural pattern. Three prominent contenders in this arena are MVC (Model-View-Controller), MVP (Model-View-Presenter), and MVVM (Model-View-ViewModel). Each offers distinct advantages and caters to projects of varying complexity. Let’s delve into their functionalities to determine which one reigns supreme for your next Android masterpiece.The OG on the Block: MVC (Model-View-Controller)MVC, the granddaddy of them all, is a well-established pattern that separates your app into three distinct layers: Model: The heart of your app, it encapsulates the data and business logic. View: The visual representation of the data, responsible for UI elements and user interaction. Controller: The glue that binds them, handling user interactions, updating the Model, and notifying the View of changes.MVC’s Strengths Simplicity: Easy to grasp for beginners due to its clear separation of concerns. Widely Adopted: Abundant resources and learning materials available. Testable Model: The Model can be unit tested in isolation.MVC’s Weaknesses Tight Coupling: View and Controller are tightly linked, making UI changes impact the Controller and vice versa. This can become a maintenance nightmare in complex apps. Fat Controller: The Controller can become overloaded with UI logic, reducing its testability and manageability. Limited UI Logic Testability: Testing UI logic within the Controller can be challenging.The Charmer: MVP (Model-View-Presenter)MVP introduces a new layer, the Presenter, to address the shortcomings of MVC: Model: Same as MVC, holds the data and business logic. View: Responsible for UI and user interactions, but doesn’t contain any logic (think of it as a passive component). Presenter: The mediator, handling user interactions, updating the Model, and notifying the View of changes. It decouples the View and Controller, improving maintainability.MVP’s Allure Improved Separation: Clearer separation of concerns between UI, data, and presentation logic. Testable UI Logic: The Presenter can be easily unit tested in isolation. Flexible View Implementation: The View can be easily replaced without affecting the Presenter or Model.But Don’t Be Blinded by the Charm Increased Complexity: Introducing the Presenter adds another layer, with a potentially steeper learning curve. Boilerplate Code: Setting up Presenters and their interactions can involve some repetitive code.The New Sheriff in Town: MVVM (Model-View-ViewModel)MVVM takes separation to the next level, introducing a ViewModel to manage UI data and logic: Model: Responsible for data sources. It collaborates with ViewModel for data access (get/save). View: Responsible for UI display and user interactions, but doesn’t contain any logic or data binding. ViewModel: Acts as the single source of truth for the View, handling data preparation, presentation logic, and notifying the View of changes. It leverages data binding frameworks for seamless UI updates.MVVM’s Merits Clean Separation: Strongest separation between UI, data, and presentation logic, leading to excellent maintainability and testability. Bidirectional Data Binding: Frameworks like Data Binding Library simplify data flow between View and ViewModel. Testable UI Logic: The ViewModel can be easily unit tested.Is MVVM Always the Right Choice? Steeper Learning Curve: Understanding data binding and interactions between View, ViewModel, and Model can be challenging for beginners. Potential Over-engineering: MVVM might be overkill for very simple apps.Choosing Your Architectural ChampionThe ideal architecture pattern depends on your project’s complexity and team’s experience: Simple Apps: MVC can be a good starting point due to its simplicity. Medium-Sized Apps: MVP offers a good balance between maintainability and complexity. Complex Apps: MVVM provides the cleanest separation and best testability.Remember, these are just guidelines. Consider your specific project needs and team expertise when making your decision. No matter which pattern you choose, a well-structured architecture will keep your Android app healthy and scalable for the future." }, { "title": "Taming the Wild West - Structured Concurrency for Reliable Asynchronous Programming", "url": "/posts/Structured-Concurrency/", "categories": "Tech", "tags": "Coroutine", "date": "2024-04-17 05:14:00 +0000", "snippet": "The world of software development thrives on getting things done concurrently. But with great concurrency comes great responsibility – the responsibility to write clean, maintainable, and bug-free code. This is where structured concurrency steps in, offering a structured approach to managing asynchronous tasks and taming the wild west of concurrent programming.The Challenge of Unstructured ConcurrencyTraditional approaches to concurrency often involve manual thread management and callbacks. This can lead to: Spaghetti Code: Complex logic intertwined with thread creation, synchronization primitives, and callbacks can create a tangled mess. Hidden Bugs: Race conditions and other concurrency errors become difficult to identify and debug due to the lack of clear execution flow. Maintenance Headaches: Modifying such code becomes a daunting task, as understanding the intended behavior and potential side effects can be challenging.Structured Concurrency: Building with ClarityStructured concurrency introduces an organized approach to writing asynchronous code. It focuses on: Encapsulating Concurrent Execution: Control Flow Constructs: Structured concurrency utilizes well-defined constructs (like keywords or libraries) for creating, executing, and terminating concurrent tasks. These constructs have clear beginning and ending points, making program flow more predictable. Explicit Scope: Similar to functions or loops, structured concurrency constructs define a clear scope for concurrent activities. This defined scope allows developers to reason about concurrent behavior and avoid issues like race conditions, where multiple threads try to access the same data simultaneously. Benefits of a Structured Approach Reduced Errors: By enforcing a structured approach, structured concurrency helps prevent accidental concurrency errors. Clear boundaries and defined execution paths minimize unintended interactions between concurrent tasks. Improved Maintainability: Code written with structured concurrency is easier to understand and modify. The well-defined scopes and control flow structures improve clarity regarding concurrent behavior within each block. Enhanced Debugging: Debugging concurrent issues becomes simpler with structured concurrency. Defined scopes allow developers to pinpoint the location of potential errors more effectively. Error Handling and Cancellation: Structured concurrency constructs often provide mechanisms for handling errors and cancelling concurrent tasks within their defined scope. This promotes robust error handling in asynchronous applications.Implementing Structured ConcurrencyThe specific implementation of structured concurrency depends on the programming language and libraries used. Here are some common approaches: Coroutine Scopes: Some languages offer coroutine scopes, which define a block of code where coroutines are launched and managed. The scope ensures all launched coroutines complete or are cancelled before the scope exits. Task Groups: Libraries might provide task groups that group concurrent tasks together. This allows for coordinated management and error handling within the group. Async/Await Syntax: Some languages use async/await syntax to manage asynchronous operations in a structured manner. Async/await provides a more readable way to express asynchronous programming logic, improving code clarity.Conclusion: Embrace the StructureStructured concurrency fosters a disciplined approach to writing concurrent programs. By encapsulating concurrent execution within clearly defined scopes and control flows, it reduces errors, improves code maintainability, and simplifies debugging. This paves the way for writing reliable and robust applications that can effectively harness the power of concurrency.So, the next time you delve into asynchronous programming, consider embracing structured concurrency. It might just be the missing piece in your journey towards clean, maintainable, and bug-free concurrent code!" }, { "title": "Unveiling Coroutines - Stackful vs. Stackless and How Kotlin Does It", "url": "/posts/Unveiling-Coroutines/", "categories": "Tech", "tags": "Coroutine", "date": "2024-04-17 04:12:00 +0000", "snippet": "IntroductionThe world of asynchronous programming thrives on concurrency, and coroutines have emerged as powerful tools to manage concurrent tasks efficiently. But within the realm of coroutines, there lies a distinction: stackful and stackless. This blog post will delve into these concepts and explore how Kotlin leverages stackless coroutines for asynchronous mastery.Stackful Coroutines: A Familiar FriendImagine a function call. It utilizes a portion of the program’s memory stack to store information about its execution, local variables, and the return address. Stackful coroutines operate similarly. Each coroutine possesses its own stack space, just like a regular function. Suspension and Resumption: When a stackful coroutine needs to pause its execution (yield control), it saves its current state (local variables, program counter) on its dedicated stack. When resumed, it retrieves the state from the stack and continues execution. Advantages: Simpler Implementation: The stack-based approach mirrors function calls, making stackful coroutines easier to understand and debug. Control Granularity: Developers have more control over the coroutine’s stack allocation and memory usage. Disadvantages: Stack Overflow Woes: Each coroutine’s dedicated stack space can lead to stack overflow errors if too many coroutines are created. Context Switching Overhead: Switching between coroutines involves saving and restoring the state on the stack, which can be inefficient for a high number of coroutines. Stackless Coroutines: A Lightweight AlternativeStackless coroutines break free from the constraints of dedicated stacks. Here’s what sets them apart: No Stack, No Problem: Unlike their stackful counterparts, stackless coroutines don’t have their own stack space. Instead, a separate “coroutine scheduler” manages their state. This scheduler allocates memory for coroutine data and handles context switching. Suspension and Resumption Redefined: When a stackless coroutine yields control, the scheduler saves its state (registers, program counter) in a lightweight data structure. The scheduler then switches to another coroutine. When the first coroutine resumes, its state is restored from the data structure, and it picks up where it left off. Advantages: Lightweight Champion: The lack of dedicated stacks makes stackless coroutines lightweight, enabling a vast number of concurrent coroutines without stack overflow concerns. Context Switching Efficiency: Switching between coroutines involves manipulating a data structure managed by the scheduler, potentially faster than stack-based operations. Disadvantages: Complexity Curve: Understanding and debugging stackless coroutines can be trickier due to the absence of a dedicated stack for each coroutine. Less Control at the Helm: Developers have less control over the coroutine’s memory usage and scheduling behavior compared to stackful coroutines. Choosing the Right Coroutine for the JobThe choice between stackful and stackless coroutines depends on your project’s requirements: For simpler applications with a limited number of coroutines, stackful coroutines might be suitable due to their straightforward implementation. For applications demanding a high volume of concurrent tasks and peak performance, stackless coroutines, like those employed by Kotlin, become the clear choice due to their scalability and efficiency.Kotlin Coroutines: Embracing the Stackless PowerKotlin, a modern language known for its developer-friendly features, takes the stackless coroutines approach. Here’s why: Memory Efficiency: Kotlin coroutines rely on a coroutine scheduler for state management, eliminating the need for individual stacks and promoting efficient memory usage. Performance Champion: The stackless design allows for faster context switching between coroutines, contributing to overall application performance. Simplified Asynchronous Programming: Kotlin provides a well-designed coroutine API that streamlines asynchronous programming compared to manual thread management.By understanding the concepts of stackful and stackless coroutines, you can make informed decisions when building asynchronous applications. Kotlin’s stackless coroutine implementation empowers developers to write clean, concurrent, and performant code. So, the next time you delve into asynchronous programming, consider the power of stackless coroutines and how Kotlin makes asynchronous development a breeze!" }, { "title": "Mastering Kotlin Coroutines in Android Development", "url": "/posts/master-kotlin-coroutine/", "categories": "Tech", "tags": "Android, Coroutine", "date": "2024-04-16 07:19:00 +0000", "snippet": "In the ever-evolving world of Android development, building responsive and efficient apps is paramount. Traditional threading approaches often lead to complex code and potential pitfalls. Enter Kotlin coroutines, a powerful tool that simplifies asynchronous programming, making your Android apps smoother and more maintainable.This blog post delves into the world of Kotlin coroutines, guiding you through their core concepts, practical usage in Android development, and best practices for leveraging their potential.What are Kotlin Coroutines?Kotlin coroutines are lightweight threads that offer a structured approach to handling asynchronous tasks without the complexity of traditional threading. Unlike threads, coroutines are suspended and resumed, allowing them to be more efficient and less resource-intensive. This suspension capability empowers them to “pause” execution while waiting for something to happen (e.g., network call completion) without blocking the main thread.Key Concepts: Coroutine Builders: These functions like launch and async help you create and launch coroutines. Coroutine Context: This defines the environment in which a coroutine executes, specifying details like dispatcher (thread pool) and exception handling. Coroutine Scope: A structured way to manage the lifecycle of coroutines, ensuring proper cancellation upon completion or error. Popular scopes include lifecycleScope in Activities/Fragments and viewModelScope in ViewModels. Suspending Functions: Functions marked with the suspend keyword can pause execution and be resumed later. Network calls and disk I/O operations are often implemented as suspending functions.Benefits of Using Coroutines: Improved Performance: Coroutines avoid blocking the main thread, preventing UI freezes during asynchronous tasks. Simplified Code: The structured approach of coroutines leads to cleaner and more readable code compared to traditional threading. Error Handling: Coroutines provide mechanisms for handling exceptions and propagating them within the coroutine hierarchy. Cancellation: You can gracefully cancel coroutines when they are no longer needed, preventing wasted resources.Putting Coroutines into Action:Here’s a simple example demonstrating how to fetch data from an API using coroutines:fun fetchData() { viewModelScope.launch { // Launch a coroutine in the viewModelScope val data = try { val response = URL(&quot;[https://api.example.com/data](https://api.example.com/data)&quot;).readText() // Parse the response and return the data parseData(response) } catch (e: Exception) { // Handle network or parsing errors null } // Update UI with the fetched data updateData(data) }}In this example, the fetchData function launches a coroutine within the viewModelScope. The coroutine fetches data from an API using a suspending function (readText). If successful, the data is parsed and used to update the UI. Any errors during the process are handled gracefully.Best Practices: Use structured concurrency: Leverage coroutine scopes to manage the lifecycle of coroutines effectively. Handle exceptions: Implement proper error handling mechanisms to prevent crashes and maintain app stability. Cancel unnecessary coroutines: When a coroutine is no longer needed, cancel it to avoid resource leaks. Use Dispatchers wisely: Choose the appropriate dispatcher (thread pool) based on the nature of the coroutine’s task (e.g., I/O for network calls, Default for CPU-bound tasks).Conclusion:Kotlin coroutines empower you to write asynchronous code in a structured and efficient manner, leading to smoother and more responsive Android applications. By understanding the core concepts, practical usage examples, and best practices, you’ll be well on your way to mastering this powerful tool in your Android development journey." }, { "title": "Summary for 2023", "url": "/posts/Summary-Of-2023/", "categories": "Summary", "tags": "My", "date": "2023-12-29 08:47:00 +0000", "snippet": "Improvements: Enhanced proficiency in English communication skills. Prioritized quality time with my family, especially with my young daughter.Key Lessons Learned: Acknowledged the importance of prioritizing self-care for both physical and mental well-being. Cultivated patience in relationships, particularly with my spouse and parents. Developed resilience against external negativity and opinions. Embraced challenges in additional work opportunities. Maintained focus on personal and professional goals. Fostered confidence in my chosen path and adopted a more positive mindset. Practiced tuning out mental noise and finding inner peace. Embraced the concept of accepting things beyond our control.Hopes for 2024: Apply the lessons learned in 2023. Increase earnings through personal efforts. Plan and enjoy family travels. Attain a native speaker level of English proficiency." }, { "title": "Do it Anyway — Mother Teresa", "url": "/posts/Do-it-Anyway/", "categories": "North Star", "tags": "Poem", "date": "2023-05-17 07:28:00 +0000", "snippet": "People are often unreasonable, illogical, and self-centered.Forgive them anyway.If you are kind,people may accuse you of selfish ulterior motives.Be kind anyway.If you are successful,you will win some false friends and some true enemies.Succeed anyway.If you are honest and frank,people may cheat you.Be honest and frank anyway.What you spend years building,someone could destroy overnight.Build anyway.If you find serenity and happiness,they may be jealous.Be happy anyway.The good you do today,people will often forget tomorrow.Do good anyway.Give the world the best you have,and it may never be enough.Give the best you’ve got anyway.You see,in the final analysis it is between you and God;it was never between you and them anyway." }, { "title": "步步高企业文化", "url": "/posts/BBK-core-values/", "categories": "North Star", "tags": "Core Values", "date": "2022-08-01 02:15:00 +0000", "snippet": "什么是企业文化？是指企业经营实践过程中，逐步形成的为全体员工所认同、遵守，带有本企业特色的价值观念。企业文化是无形的制度，是共同的语言，是共同的想法，是一致的行为方式。一、愿景 愿景是一种意愿的表达“它定义了我们渴望成为什么，达到什么境界，创造出什么”是公司为之奋斗的心愿和远景。我们公司的愿景：成为更健康、更长久的企业。利润（赚钱）是生存的必要条件，是实现更健康、更长久的手段。利润就像人体的氧气、食物和水一样 —— 没有他们，就没有生命。创造利润（赚钱）是公司的责任，一个不赚钱的公司是不能长久的。但是，赚钱不是我们的最终目的的，它是实现愿景的过程。这就像氧气、食物和水一样 —— 这些东西不可或缺，但它们不是生命的目的。所以，我们需要创造利润，但我们更需要追求更广泛、更有意义的理想 —— 成为更健康、更长久的世界一流企业。尽管在某些事情上我们可能可以获得短期利益（表面上看起来似乎暂时“对公司有利”），但如果因此而影响到公司长远的安全和健康，这种事情我们决不能做。追求愿景意味着我们必须要脚踏实地，做对的事情，不是本分的事情坚决不做；同时要求我们在永恒保存核心价值的基础上，积极改变除此之外的任何东西，以获得追求进步的驱动力。我们在创建基业长青的事业，这是我们的诺言，是不言自明的真理。50年后，100年后，甚至更长的时间后，当人们审视步步高公司时，仍然会说：“这是一个基业长青的伟大公司…….”二、使命 使命是公司根本的、崇高的责任和义务，是公司存在的基本原因，它定义了不变的“我们为什么存在” 。我们公司的使命： 对消费者，提供品质优良的产品和服务。 对员工，营造和谐、相互尊重的工作氛围。 对商业伙伴，提供公平合理、对等互利的合作平台。 对股东，使其投入的股本有高于社会平均收益的回报。   我们的首要责任是对所有购买和使用我们产品的消费者负责。我们的产品品质和服务品质必须要满足消费者的需求，并且高于对竞争对手的满意度。我们必须不断致力于降低产品的成本，从而让更多的消费者能购买和使用我们的产品。我们必须不断缩短产品订单的交货期，以最快的速度满足消费者的需要。我们致力于在产品和服务方面给顾客带来超凡的消费体验，让消费者感受到产品的精美和高品质、服务的完善和细心。 我们的第二个责任是对在公司所有岗位工作的全体同仁负责。我们要为员工提高学习和锻炼的机会，帮助员工提高基本素质、业务能力和综合素质。我们要为既合适又合格的员工提供晋升的机会，在考核一个人时以道德品质和价值观念为基本依据。我们提供的工资必须公平而适当，管理者必须公平公正，员工的工作环境必须整洁安全。我们尊重和珍视每位员工的价值，我们相信，员工应该和公司共同成长，这是我们的责任和骄傲。 我们的第三个责任是对我们的供应商、经销商及其他所有商业伙伴负责。我们做生意追求的是“商道”而非“商术”，我们首先要考虑合作伙伴的应有利润。在此基础上再追求自己的合理利润，给每一位商业伙伴提供公平互利的合作平台。我们选择和评价商业伙伴时，关注的是品质、价格和服务，以及诚信合作的一贯性，而不需考虑关系的亲疏及其他社会因素。我们希望和我们的合作伙伴共同成长。 我们的第四个责任是对股东负责。我们必须赚取合理的相当利润，才能研发新项目、制造新产品、实践新构想、制订新规划、支付合适的工资。我们尽到这一切责任后，股东们应该得到公平合理的回报。公司健康、长久的发展离不开投资者（股东）的信任和支持，我们必须给予投资者（股东）坚定的信心和公平的报偿。这是公司得以存在的基础，也是我们诚信文化的体现。 三、核心价值观 核心价值观是公司的精神和持久的原则——是一套不需要外部调整的永恒指导原则，它对于公司内部的人拥有的价值和意义。它定义了不变的“我们代表什么” 。我们核心价值观的中心是“本分” ，它是我们价值观的灵魂，它决定了其他所有的观念和处事的原则。本分做到之后，其他的核心价值观都会被涵盖进去。我们核心价值观的基础是“消费者导向” ，消费者的需求（含显在和潜在的需求）是所有企业活动的原始起点。本分： 做对的事情（有所为有所不为），把事情做对； 专注于自己所从事的工作，把结果放到第一位； 隔离外力，在平常的心态下，把握住我们应该做的合理方向； 本份规范了与人合作的态度——我不赚人便宜； 本分是当出现问题时，首先求责于己的态度。 压力和诱惑往往会使我们平常清静的心态受到震荡，而这种改变的结果大多将使我们偏离正确的方向。本分则是在决策和行动时，我们能够首先将这种外在的作用力先行抛开，在平常的心态下，把握住我们应该做的合理的方向，而不是首先被外在的作用力所牵引，以致作出错误的选择。我们宁愿自己吃点小亏，也不会去赚别人的便宜，这样做生意往往才能够取得双赢，也才能长久。我们在做生意时追求的是“商道”而非“商术”。 “商道”要求我们首先要考虑合作伙伴的应有利益，在此基础上再追求自己的合理利润，而绝非为了赚钱不择手段、损人利己。出现问题时，我们不需要任何借口和理由，我们应该首先求责于己，反省自己做错了什么，应该如何去改善。如何做到本分： 本分是付出代价的坚持； 本分是充分考虑对方的立场，己所不欲勿施于人； 本分是兢兢业业，做自己该做的事； 本分是不骄不躁，克己尽职； 本分是诚实守信，说到做到； 本分是不占小便宜；本分和诚信的不同：本分和诚信的不同是在于诚信是双方面的，有约定的，而本分是不需要约定的，是自己主动知道要这样去做的。本分比诚信要高一个境界，它体现的是我们灵魂深处的东西。本分涵盖了其他几项核心价值观（诚信、团队、品质、消费者导向），而诚信是本分一个方面的体现。诚信： 百德诚为先，百事信为本； 不轻易的承诺，如果承诺了就一定要做到； 诚，即诚实、无欺，内诚于心； 信，即守承诺、讲信用，说到做到，外信于人，即使遭遇挫折、付出代价也要坚守； 诚信是一种责任、准则和资源。我们要在自己的内心深处架起一杆道德天平，诚者不伪，无论外部环境怎样变化，都要忠实于内心的道德法则，真诚为人，不自欺，不欺人，这样才是内诚于心。我们忠实于自己做出的每一个承诺，言必行，行必果，即使要为此付出艰难的努力、巨大的代价，也要恪守“说到就要做到”的准则，这样才能外信于人。诚信不仅是一种品行，更是一种责任，不仅是一种道义，更是一种资源。我们把产品推向社会的过程。我们卖给顾客的不仅是商品，更是用心铸造的庄严承诺。我们用心设计品质、制造产品，用心沟通伙伴、服务顾客，用心锤炼品牌、树立形象。我们约束自己，诚笃于胸；我们言出必行，行出必果。团队： 主动配合支持他人； 实现优势的整合，追求共赢； 没有团队的成功，就没有个人的成功； 相互信任，坦诚沟通，将个人融入团队，以共同愿景为最高目标。 尊重每一位员工的价值，我们相信，员工和公司共同成长，这是我们的责任和骄傲。 我们每个人的成功，都必须建立在团队成功的基础上。步步高的任何人，无论是要个人的能力价值得到发挥，还是要物质利益得到提高，前提都必须是步步高整个团队要取得成功。而一个成功的团队又会带给我们很多有形和无形的资产，会让我们终生受益。团队中难免会有分歧，重要的是不能让分歧影响团队目标的达成。这就需要我们时刻用团队目标和共同愿景来审视自我，自觉将个人融入团队，相互信任，坦诚沟通，这样我们就能够撇弃偏见，协同工作，达成我们的共同目标。步步高珍重和珍视每一位员工的价值。我们鼓励员工在工作中不断提升自我，并努力激发员工的潜能。因为我们相信，员工应该和公司共同成长，这是我们的责任和骄傲。品质： 没有品质一切都是负数； 以品质取得信任，以品牌提升价值； 品质是做出来的，不是检验出来的； 品质就是生命； 品质是精益求精的一种追求，是必须要满足顾客的需求并且高于对竞争对手的满意度； 品质是设计出来的，是全员关心和环环相扣的一个系统工程； 不断提升产品品质，这不仅是我们的价值，更是我们的尊严。 顾客需求的是全面的品质，包括产品的精美度、人性化、可靠性和性价比。我们不仅要满足顾客需求，更要比竞争对手做得更多更好，让消费者更满意。品质是精益求精的一种追求，是一种要不断靠近、一种发自内心的真诚的向往和渴望。品质是设计出来的，我们会主动贴近市场，努力发掘所有可能为顾客带来愉悦感受的潜在机会，并将之转化为设计语言。我们在设计产品时，以追求产品的人性化、精美度和零缺陷为出发点，旨在产品推出时具有震撼力，能够给顾客带来超凡的消费体验，消费者能够感受到产品的精美与高品质。这就是我们一贯坚持的开发“英雄产品”的思路。我们有这样的共识：步步高公司与“步步高”品牌同生共荣，而步步高的品质又是步步高人价值与尊严的起点。我们深知，品质是企业生存之根本，没有品质就没有一切，我们对品质的追求永无止境。品质方针： 不懈进取，步步登高，为用户提供令其完全满意的产品和服务，我们的步步高品牌，必须是高品质的象征。假设大家工作时99.9%地投入，那么：每小时将有1.6万件邮件在邮寄途中丢失；每小时会有2.2万张支票被存入错误的银行账户；每天将有50个新生儿因身份被搞混，而被交给错误的父母；医院里每星期会有500例错误手术；药剂师每年将给2万个病人开错药；你的心脏每年会停止跳动3.2万次。所以：品质就是生命！消费者导向： 消费者是检验我们工作的唯一标准； 步步高不仅注重消费者需求，也注重消费者购买后的评价。 从消费者的角度来设计产品、提高服务，避免做貌似消费者喜欢的东西； 通过科学、严谨的市场调查，充分地研究消费者的需求，消费者的需求是所有企业活动的原始起点； 在公司内部的日常工作中，要坚持内部客户导向的原则。 我们公司的所有经营活动必须要首先从消费者的角度来看，这是消费者需要的吗，消费者会喜欢吗，然后再从这个角度来开发产品、提供服务——这就是消费者导向。我们要坚决避免做貌似消费者喜欢的东西。市场上必定存在这样的需求：它是消费者所需要的、我们能够做出优势，并且能比竞争对手更好的满足消费者。我们要去寻找、挖掘和发现这种需求，巧妙的将产品在功能和技术上的创新优势转化为消费者的利益，在满足消费者需求和发挥我们自身特色上保持良好的平衡。在公司内部，有我们各自的内部顾客 。我们工作时首先要弄清楚，自己的直接客户是谁，他喜欢我所做的工作吗，我所到的结果正是他需要的吗。我们工作的目的不是为了完成任务，而是为了创造卓越的结果，使顾客更满意。内部客户导向是消费者导向在公司内部日常工作中的表现。———— 这叫彻底消费者导向！   作者：思弦君 链接：https://xueqiu.com/2740739644/172093568 来源：雪球 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 " }, { "title": "段永平 2011 年浙江大学毕业演讲", "url": "/posts/Duan-ZheJiang-University/", "categories": "North Star", "tags": "Core Values", "date": "2022-08-01 01:51:00 +0000", "snippet": " 很荣幸受到邀请，能有机会代表五十万校友跟新毕业的校友说两句。我一直在想，两三分钟我要讲点什么，能够让在场同学在二三十年后还能记得住，并且有所得益。不知道大家现在心情如何，我依然还记得自己在毕业时候那种兴奋、茫然、激动、困惑、不安、满怀希望、又有点不知所措的复杂心情。二十八年过去了，虽然这种感觉偶尔还会出现，但是在经历了这段人生之路后，会有些感悟。今天，主要以我自己的经历，跟大家分享三点，关于毕业之后，做个什么样的人。 第一，做个胸无“大”志的人。首先要强调的是，这里的“大”是好大喜功的大。所谓胸无“大”志，指的是脚踏实地的做事态度。我们要胸无“大”志地去做自己喜欢的事情，同时，还要努力去喜欢自己在做的事情。我觉得，只有在做自己喜欢的事情的时候，才能激发自己最大的潜力，所以每个人首先要花很大精力去寻找自己喜欢的事情。同时，我也要强调后面一点，喜欢自己在做的事情。大学刚毕业就马上找到自己喜欢的事情，是可遇不可求的。很多时候，当我们投入到自己的工作中后，会慢慢找到很多乐趣，在努力的过程中，会渐渐发现自己喜欢做什么。所以，努力喜欢自己做的事情很重要。胸无“大”志，需要大家慢慢体会。第二， 做个有所不为的人。我们有句话叫做“有所为，有所不为”。我们常常注意到要“有所为”，但我要强调的是“有所不为”。我很早就听说过，要做对的事情，然后把事情做对。在经历了这些年，经历很多次的头破血流之后，我才真正开始明白这句话是什么意思。所谓做对的事情，就是知道是错的事情决不要做，知道做错了马上要改。这个说起来容易，做起来困难。知道做错了马上改，不管多大的代价，到最后往往是最小的代价。我看到很多人明知是错，犯了错之后抱着侥幸的心态，浪费很多年之后最后要付出更大的代价。希望大家不要碰到这样的情况。很多人问我，为什么我们公司在消费电子领域这么多年之后一直存在，我们就是守诚信、平常心、坚守本分。本分就是有所不为的意思。把事情做对，本身是个学习的过程，这个过程当中是要犯很多错误的。有种说法“不怕犯错误”，我们做对的事情时，要避免犯错，但把事情做对的过程中会犯很多错误，这个大家要理解。还有个说法“永不放弃”，就是要坚持对的事情，如果是错的事情，要立即回头。第三，做个正直的人。无论能否做到以上两点，但最基本的是要做个正直的人。我不知道做个正直的人，会有什么回报，但至少让人一生坦然。我就讲这三点，大学毕业是我们进入社会大学的起点，我们要学习的东西是无穷无尽的。最后，衷心祝愿每一位同学都能找到属于自己的精彩人生。   作者：思弦君 链接：https://xueqiu.com/2740739644/172834396 来源：雪球 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 " }, { "title": "是非，毁誉，得失", "url": "/posts/POEM-Right-And-Wrong/", "categories": "Self-improvement", "tags": "Poem", "date": "2022-07-19 07:42:00 +0000", "snippet": "[湖南] 岳麓书院上联： 是非审之于己，毁誉听之于人，得失安之于数，陟岳麓峰头，朗月清风，太极悠然可会下联：君亲恩何以酬，民物命何以立，圣贤道何以传，登赫曦台上，衡云湘水，斯文定有攸归" }, { "title": "竹石", "url": "/posts/POEM-Bamboo-In-The-Stone/", "categories": "Self-improvement", "tags": "Poem", "date": "2022-06-30 02:04:00 +0000", "snippet": "[清] 郑燮咬定青山不放松立根原在破岩中千磨万击还坚劲任尔东西南北风" }, { "title": "定风波", "url": "/posts/POEM-Still-the-Turbulence/", "categories": "Self-improvement", "tags": "Poem", "date": "2022-06-30 01:36:00 +0000", "snippet": "[宋] 苏轼 三月七日，沙湖道中遇雨。雨具先去，同行皆狼狈，余独不觉。已而遂晴，故作此词。莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。" }, { "title": "君子", "url": "/posts/POEM-Gentleman/", "categories": "Self-improvement", "tags": "Poem", "date": "2022-05-24 02:25:00 +0000", "snippet": "[中庸]君子素其位而行，不愿乎其外。素富贵，行乎富贵；素贫贱，行乎贫贱；素夷狄，行乎夷狄；素患难，行乎患难。君子无入而不自得焉。在上位，不陵下；在下位，不援上。正己而不求于人，则无怨。上不怨天，下不尤人。故君子居易以俟命，小人行险以徼幸。 子曰：“射有似乎君子，失诸正鹄，反求诸其身。”" }, { "title": "Android Studio 手动关联源码", "url": "/posts/android-studio-link-source/", "categories": "Tech", "tags": "Android", "date": "2022-05-16 09:53:00 +0000", "snippet": "备注如果只是方便在 Android Studio 中查看 Android Framework 的源码，那么最好的方法还是直接通过 Android Studio 的 Android SDK 页面下载。本文描述的问题和解决方案是在网络出问题的情况下遇到的，正常开发过程应该不会有类似的问题，仅做记录和参考。问题可能是网络出了问题，当通过 Android Studio 下载 API Level 31 的源码时，总是提示失败，到 SDK 配置的页面， 在勾选 Show Package Details 的情况下，也没看到 API Level 31 的 source 下载选项，误以为是不是 google 没有提供这个版本的源码，但是项目的 Compile SDK Level 正好配置的 31，在这种情况下，如果想看 Android framework 的源码，只能通过修改 Compile SDK Level 和 手动关联源码的方式来解决。项目上还有其他协同开发的同事，冒然修改 Compile SDK 不是很合适。那就剩手动关联源码的解决方案了。方案要手动关联源码，首先需要知道 Android Studio 的源码关联机制是怎么工作的，这个有很多资料可查，不在本文详述。解决步骤： 找到存储源码和对应 SDK 版本关联关系的配置文件 手动添加下载的源码和 SDK 的关联关系配置文件在 Android Studio 上，关联关系存储在如下位置：~/Library/Application Support/Google/AndroidStudio{version}/options/jdk.table.xml比如我本地环境的配置文件存储在：~/Library/Application Support/Google/AndroidStudio2021.1/options/jdk.table.xml添加配置如果相关 SDK 的配置节点已经存在，则只需检查 &amp;lt;sourcePath&amp;gt; 节点是否存在，如果不存在，则添加对应的路径&amp;lt;jdk version=&quot;2&quot;&amp;gt; &amp;lt;name value=&quot;Android API 31 Platform&quot; /&amp;gt; &amp;lt;type value=&quot;Android SDK&quot; /&amp;gt; &amp;lt;version value=&quot;version 11.0.11&quot; /&amp;gt; &amp;lt;homePath value=&quot;$USER_HOME$/Library/Android/sdk&quot; /&amp;gt; &amp;lt;roots&amp;gt; &amp;lt;annotationsPath&amp;gt; &amp;lt;root type=&quot;composite&quot;&amp;gt; &amp;lt;root url=&quot;jar://$USER_HOME$/Library/Android/sdk/platforms/android-31/data/annotations.zip!/&quot; type=&quot;simple&quot; /&amp;gt; &amp;lt;/root&amp;gt; &amp;lt;/annotationsPath&amp;gt; &amp;lt;classPath&amp;gt; &amp;lt;root type=&quot;composite&quot;&amp;gt; &amp;lt;root url=&quot;jar://$USER_HOME$/Library/Android/sdk/platforms/android-31/android.jar!/&quot; type=&quot;simple&quot; /&amp;gt; &amp;lt;root url=&quot;file://$USER_HOME$/Library/Android/sdk/platforms/android-31/data/res&quot; type=&quot;simple&quot; /&amp;gt; &amp;lt;/root&amp;gt; &amp;lt;/classPath&amp;gt; &amp;lt;javadocPath&amp;gt; &amp;lt;root type=&quot;composite&quot; /&amp;gt; &amp;lt;/javadocPath&amp;gt; &amp;lt;sourcePath&amp;gt; &amp;lt;root type=&quot;composite&quot;&amp;gt; &amp;lt;root url=&quot;file://$USER_HOME$/Library/Android/sdk/sources/android-31&quot; type=&quot;simple&quot; /&amp;gt; &amp;lt;/root&amp;gt; &amp;lt;/sourcePath&amp;gt; &amp;lt;/roots&amp;gt; &amp;lt;additional jdk=&quot;Android Studio default JDK&quot; sdk=&quot;android-31&quot; /&amp;gt;&amp;lt;/jdk&amp;gt;重启 Android Studio" }, { "title": "Kotlin double 精度问题", "url": "/posts/double-precision-issue/", "categories": "Tech", "tags": "Android", "date": "2022-05-01 06:18:00 +0000", "snippet": "问题在项目上有同事写了一段代码，主要功能是将用户输入的纯数字字符串按照美国货币格式展示，比如输入 “1234” -&amp;gt; “1,234”。他的实现方法是先将字符串转换成 double ，再通过 NumberFormat 将其格式化为货币格式。在字符串长度小于16时，能正常工作，但是当字符串长度大于等于16时就会出现异常，比如用户输入的字符串是 “9999999999999999” (16 个 9)，期望展示的结果是 “9,999,999,999,999,999”，实际结果是 “10,000,000,000,000,000”。开始大家认为是输入的数字过大，超过了 double 所能表示的数据范围，数据溢出导致结果出错。这个问题超出了我的知识边界，所以一开始我也没想清楚为什么？但是心里产生了一个疑问：如果真是数据溢出了，那么 double 能够处理的数据范围是多少？带着这个问题，我在网上查阅了相关资料，大体弄明白了这个问题的原因。double 的存储原理下面这张图清晰的描述了双精度浮点数的存储原理double 的数据范围根据存储原理，11 位指数位能够表示的数据范围是 10^-308^ 和 10^308^ 之间的数字，具有完整的 15-17 位十进制数字精度。整数的精度限制53 位有效数字精度提供 15 到 17 位有效十进制数字精度 (2^53^ ≈ 1.11 × 10^16^) 可以精确表示从 -2^53^ 到 2^53^（-9,007,199,254,740,992 到 9,007,199,254,740,992）的整数 2^53^ 和 2^54^ 之间的整数 = 18,014,398,509,481,984 舍入为 2 的倍数（偶数） 2^54^ 到 2^55^ 之间的整数 = 36,028,797,018,963,968 舍入为 4 的倍数 double 与 string 的转换按照 IEEE 754 标准，如果将一个至多 15 位有效数字的十进制字符串，转换为 double 表示，然后再转换为十进制字符串，则最终结果与原始的字符串匹配。但是对于超过 15 位的字符串，只能够保证，将一个至少 17 位的 double 转换为十进制字符串，然后再转换为 double 表示时，最终结果必须与原始数字匹配。参考内容Double-precision floating-point format浮点数的二进制表示" }, { "title": "Android 模拟器不能使用电脑的代理网络", "url": "/posts/android-emulator-network-issue-copy/", "categories": "Tech", "tags": "Android", "date": "2022-04-28 13:24:00 +0000", "snippet": "问题做 Android 开发经常需要和模拟器打交道，在特定的业务场景下，需要模拟器能够使用电脑的 VPN 网络，不做一些特别的配置，模拟器是不能使用电脑 VPN 网络的。要解决模拟器的网络问题，需要弄清楚下面三个问题： 模拟器网络工作原理 网络代理的工作原理 如何让模拟器使用电脑的网络代理这三个问题都能在 Google 给的 模拟器网络搭建 找到答案模拟器网络工作原理官方文档在开始简略的介绍了模拟器的网络工作原理，总结下面几条 模拟器具备独立的网络系统，与开发机和其他模拟器的网络系统隔离 模拟器无法直接通过网络访问开发机或其他模拟器 模拟器运行独立的 router 系统，管理的 IP 地址段为 10.0.2/24 模拟器地址空间已经按照规则预先分配 IP地址 描述 10.0.2.1 网关 10.0.2.2 主机环回地址的别名，即对应开发机的 localhost 10.0.2.3 模拟器的第一 DNS 服务器地址 127.0.0.1 模拟器的环回地址，不对应开发机的 127.0.0.1 代理的工作原理网络代理和现实生活中的代理，概念一致，即作为客户端和服务端的中间人，代理客户端所有的请求，从服务端拿到资源后，再返回给客户端。客户端和服务端不直接联系。 具体的原理可以参考 Proxy server如何让模拟器能够使用电脑的代理如果能够给模拟器设置一个代理服务器，同时这个代理服务器又把所有请求转发给开发机的代理服务器，似乎就能解决问题。这个方案实施，需要满足两个条件 模拟器可以设置全局网络代理 模拟器的代理服务器可以转发请求给开发机的代理服务器第一个条件很简单，因为模拟器本身就支持设置全局代理。第二个条件要怎么实现呢？ 在模拟器网络工作原理这一节，我们知道，模拟器的网络是独立于开发机的网络的，有一套独立的路由体系。但是这种独立并非完全没有联系，在预制的 IP 地址中，我们可以知道 10.0.2.2 这个地址就对应了开发机的 localhost，也即开发机的 127.0.0.1 这个 IP。所以只要我们把代理服务运行的IP(10.0.2.2) 和 端口(比如: 7890) 设置到模拟器的全局代理上，就可以让模拟器使用开发机的代理。参考内容LocalhostLoopackProxy ServerVPN" }, { "title": "开始", "url": "/posts/get-started/", "categories": "Thought", "tags": "My", "date": "2022-04-27 15:02:00 +0000", "snippet": "想了很久，决定通过博客来记录自己的成长历程，2017年 已经用 github pages 搭建了自己的博客系统，但是一直未真正开始写。最近反复思考之后，觉得博客对于未来自己要做的事情蛮重要的，所以重新开始了，希望自己能够一直坚持下来，也相信自己能够坚持下来。亡羊补牢，为时未晚！" } ]
